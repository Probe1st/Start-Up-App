"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCollection = isCollection;
exports.isNode = isNode;
exports.isSeq = exports.isScalar = exports.isPair = exports.isMap = exports.isDocument = exports.isAlias = exports.hasAnchor = exports.SEQ = exports.SCALAR = exports.PAIR = exports.NodeBase = exports.NODE_TYPE = exports.MAP = exports.DOC = exports.ALIAS = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ALIAS = Symbol["for"]('yaml.alias');
exports.ALIAS = ALIAS;
var DOC = Symbol["for"]('yaml.document');
exports.DOC = DOC;
var MAP = Symbol["for"]('yaml.map');
exports.MAP = MAP;
var PAIR = Symbol["for"]('yaml.pair');
exports.PAIR = PAIR;
var SCALAR = Symbol["for"]('yaml.scalar');
exports.SCALAR = SCALAR;
var SEQ = Symbol["for"]('yaml.seq');
exports.SEQ = SEQ;
var NODE_TYPE = Symbol["for"]('yaml.node.type');
exports.NODE_TYPE = NODE_TYPE;

var isAlias = function isAlias(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === ALIAS;
};

exports.isAlias = isAlias;

var isDocument = function isDocument(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === DOC;
};

exports.isDocument = isDocument;

var isMap = function isMap(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === MAP;
};

exports.isMap = isMap;

var isPair = function isPair(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === PAIR;
};

exports.isPair = isPair;

var isScalar = function isScalar(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === SCALAR;
};

exports.isScalar = isScalar;

var isSeq = function isSeq(node) {
  return !!node && _typeof(node) === 'object' && node[NODE_TYPE] === SEQ;
};

exports.isSeq = isSeq;

function isCollection(node) {
  if (node && _typeof(node) === 'object') switch (node[NODE_TYPE]) {
    case MAP:
    case SEQ:
      return true;
  }
  return false;
}

function isNode(node) {
  if (node && _typeof(node) === 'object') switch (node[NODE_TYPE]) {
    case ALIAS:
    case MAP:
    case SCALAR:
    case SEQ:
      return true;
  }
  return false;
}

var hasAnchor = function hasAnchor(node) {
  return (isScalar(node) || isCollection(node)) && !!node.anchor;
};

exports.hasAnchor = hasAnchor;

var NodeBase =
/*#__PURE__*/
function () {
  function NodeBase(type) {
    _classCallCheck(this, NodeBase);

    Object.defineProperty(this, NODE_TYPE, {
      value: type
    });
  }
  /** Create a copy of this node.  */


  _createClass(NodeBase, [{
    key: "clone",
    value: function clone() {
      var copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range) copy.range = this.range.slice();
      return copy;
    }
  }]);

  return NodeBase;
}();

exports.NodeBase = NodeBase;