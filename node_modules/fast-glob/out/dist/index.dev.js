"use strict";

var taskManager = require("./managers/tasks");

var patternManager = require("./managers/patterns");

var async_1 = require("./providers/async");

var stream_1 = require("./providers/stream");

var sync_1 = require("./providers/sync");

var settings_1 = require("./settings");

var utils = require("./utils");

function FastGlob(source, options) {
  var works, result;
  return regeneratorRuntime.async(function FastGlob$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          assertPatternsInput(source);
          works = getWorks(source, async_1["default"], options);
          _context.next = 4;
          return regeneratorRuntime.awrap(Promise.all(works));

        case 4:
          result = _context.sent;
          return _context.abrupt("return", utils.array.flatten(result));

        case 6:
        case "end":
          return _context.stop();
      }
    }
  });
} // https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare


(function (FastGlob) {
  function sync(source, options) {
    assertPatternsInput(source);
    var works = getWorks(source, sync_1["default"], options);
    return utils.array.flatten(works);
  }

  FastGlob.sync = sync;

  function stream(source, options) {
    assertPatternsInput(source);
    var works = getWorks(source, stream_1["default"], options);
    /**
     * The stream returned by the provider cannot work with an asynchronous iterator.
     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
     * This affects performance (+25%). I don't see best solution right now.
     */

    return utils.stream.merge(works);
  }

  FastGlob.stream = stream;

  function generateTasks(source, options) {
    assertPatternsInput(source);
    var patterns = patternManager.transform([].concat(source));
    var settings = new settings_1["default"](options);
    return taskManager.generate(patterns, settings);
  }

  FastGlob.generateTasks = generateTasks;

  function isDynamicPattern(source, options) {
    assertPatternsInput(source);
    var settings = new settings_1["default"](options);
    return utils.pattern.isDynamicPattern(source, settings);
  }

  FastGlob.isDynamicPattern = isDynamicPattern;

  function escapePath(source) {
    assertPatternsInput(source);
    return utils.path.escape(source);
  }

  FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));

function getWorks(source, _Provider, options) {
  var patterns = patternManager.transform([].concat(source));
  var settings = new settings_1["default"](options);
  var tasks = taskManager.generate(patterns, settings);
  var provider = new _Provider(settings);
  return tasks.map(provider.read, provider);
}

function assertPatternsInput(input) {
  var source = [].concat(input);
  var isValidSource = source.every(function (item) {
    return utils.string.isString(item) && !utils.string.isEmpty(item);
  });

  if (!isValidSource) {
    throw new TypeError('Patterns must be a string (non empty) or an array of strings');
  }
}

module.exports = FastGlob;