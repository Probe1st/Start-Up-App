"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return expandTailwindAtRules;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _quicklru =
/*#__PURE__*/
_interop_require_default(require("@alloc/quick-lru"));

var _sharedState =
/*#__PURE__*/
_interop_require_wildcard(require("./sharedState"));

var _generateRules = require("./generateRules");

var _log =
/*#__PURE__*/
_interop_require_default(require("../util/log"));

var _cloneNodes =
/*#__PURE__*/
_interop_require_default(require("../util/cloneNodes"));

var _defaultExtractor = require("./defaultExtractor");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var env = _sharedState.env;
var builtInExtractors = {
  DEFAULT: _defaultExtractor.defaultExtractor
};
var builtInTransformers = {
  DEFAULT: function DEFAULT(content) {
    return content;
  },
  svelte: function svelte(content) {
    return content.replace(/(?:^|\s)class:/g, " ");
  }
};

function getExtractor(context, fileExtension) {
  var extractors = context.tailwindConfig.content.extract;
  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}

function getTransformer(tailwindConfig, fileExtension) {
  var transformers = tailwindConfig.content.transform;
  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}

var extractorCache = new WeakMap(); // Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.

function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new _quicklru["default"]({
      maxSize: 25000
    }));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = content.split("\n")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      line = line.trim();

      if (seen.has(line)) {
        continue;
      }

      seen.add(line);

      if (extractorCache.get(extractor).has(line)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = extractorCache.get(extractor).get(line)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var match = _step2.value;
            candidates.add(match);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        var extractorMatches = extractor(line).filter(function (s) {
          return s !== "!*";
        });
        var lineMatchesSet = new Set(extractorMatches);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = lineMatchesSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _match = _step3.value;
            candidates.add(_match);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */


function buildStylesheet(rules, context) {
  var sortedRules = context.offsets.sort(rules);
  var returnValue = {
    base: new Set(),
    defaults: new Set(),
    components: new Set(),
    utilities: new Set(),
    variants: new Set()
  };
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = sortedRules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          sort = _step4$value[0],
          rule = _step4$value[1];

      returnValue[sort.layer].add(rule);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return returnValue;
}

function expandTailwindAtRules(context) {
  return function (root) {
    var layerNodes = {
      base: null,
      components: null,
      utilities: null,
      variants: null
    };
    root.walkAtRules(function (rule) {
      // Make sure this file contains Tailwind directives. If not, we can save
      // a lot of work and bail early. Also we don't have to register our touch
      // file as a dependency since the output of this CSS does not depend on
      // the source of any templates. Think Vue <style> blocks for example.
      if (rule.name === "tailwind") {
        if (Object.keys(layerNodes).includes(rule.params)) {
          layerNodes[rule.params] = rule;
        }
      }
    });

    if (Object.values(layerNodes).every(function (n) {
      return n === null;
    })) {
      return root;
    }

    var _context_candidates; // ---
    // Find potential rules in changed files


    var candidates = new Set([].concat(_toConsumableArray((_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : []), [_sharedState.NOT_ON_DEMAND]));
    var seen = new Set();
    env.DEBUG && console.time("Reading changed files");

    if (false) {
      // TODO: Pass through or implement `extractor`
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = require("@tailwindcss/oxide").parseCandidateStringsFromFiles(context.changedContent)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var candidate = _step5.value;
          candidates.add(candidate);
        } // for (let { file, content, extension } of context.changedContent) {
        //   let transformer = getTransformer(context.tailwindConfig, extension)
        //   let extractor = getExtractor(context, extension)
        //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)
        // }

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    } else {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = context.changedContent[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _step6$value = _step6.value,
              file = _step6$value.file,
              content = _step6$value.content,
              extension = _step6$value.extension;
          var transformer = getTransformer(context.tailwindConfig, extension);
          var extractor = getExtractor(context, extension);
          content = file ? _fs["default"].readFileSync(file, "utf8") : content;
          getClassCandidates(transformer(content), extractor, candidates, seen);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }

    env.DEBUG && console.timeEnd("Reading changed files"); // ---
    // Generate the actual CSS

    var classCacheCount = context.classCache.size;
    env.DEBUG && console.time("Generate rules");
    env.DEBUG && console.time("Sorting candidates");
    var sortedCandidates = false ? candidates : new Set(_toConsumableArray(candidates).sort(function (a, z) {
      if (a === z) return 0;
      if (a < z) return -1;
      return 1;
    }));
    env.DEBUG && console.timeEnd("Sorting candidates");
    (0, _generateRules.generateRules)(sortedCandidates, context);
    env.DEBUG && console.timeEnd("Generate rules"); // We only ever add to the classCache, so if it didn't grow, there is nothing new.

    env.DEBUG && console.time("Build stylesheet");

    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
      context.stylesheetCache = buildStylesheet(_toConsumableArray(context.ruleCache), context);
    }

    env.DEBUG && console.timeEnd("Build stylesheet");
    var _context$stylesheetCa = context.stylesheetCache,
        defaultNodes = _context$stylesheetCa.defaults,
        baseNodes = _context$stylesheetCa.base,
        componentNodes = _context$stylesheetCa.components,
        utilityNodes = _context$stylesheetCa.utilities,
        screenNodes = _context$stylesheetCa.variants; // ---
    // Replace any Tailwind directives with generated CSS

    if (layerNodes.base) {
      layerNodes.base.before((0, _cloneNodes["default"])([].concat(_toConsumableArray(baseNodes), _toConsumableArray(defaultNodes)), layerNodes.base.source, {
        layer: "base"
      }));
      layerNodes.base.remove();
    }

    if (layerNodes.components) {
      layerNodes.components.before((0, _cloneNodes["default"])(_toConsumableArray(componentNodes), layerNodes.components.source, {
        layer: "components"
      }));
      layerNodes.components.remove();
    }

    if (layerNodes.utilities) {
      layerNodes.utilities.before((0, _cloneNodes["default"])(_toConsumableArray(utilityNodes), layerNodes.utilities.source, {
        layer: "utilities"
      }));
      layerNodes.utilities.remove();
    } // We do post-filtering to not alter the emitted order of the variants


    var variantNodes = Array.from(screenNodes).filter(function (node) {
      var _node_raws_tailwind;

      var parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;

      if (parentLayer === "components") {
        return layerNodes.components !== null;
      }

      if (parentLayer === "utilities") {
        return layerNodes.utilities !== null;
      }

      return true;
    });

    if (layerNodes.variants) {
      layerNodes.variants.before((0, _cloneNodes["default"])(variantNodes, layerNodes.variants.source, {
        layer: "variants"
      }));
      layerNodes.variants.remove();
    } else if (variantNodes.length > 0) {
      root.append((0, _cloneNodes["default"])(variantNodes, root.source, {
        layer: "variants"
      }));
    } // If we've got a utility layer and no utilities are generated there's likely something wrong


    var hasUtilityVariants = variantNodes.some(function (node) {
      var _node_raws_tailwind;

      return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === "utilities";
    });

    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
      _log["default"].warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]);
    } // ---


    if (env.DEBUG) {
      console.log("Potential classes: ", candidates.size);
      console.log("Active contexts: ", _sharedState.contextSourcesMap.size);
    } // Clear the cache for the changed files


    context.changedContent = []; // Cleanup any leftover @layer atrules

    root.walkAtRules("layer", function (rule) {
      if (Object.keys(layerNodes).includes(rule.params)) {
        rule.remove();
      }
    });
  };
}