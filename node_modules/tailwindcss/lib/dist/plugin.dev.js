"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setupTrackingContext =
/*#__PURE__*/
_interop_require_default(require("./lib/setupTrackingContext"));

var _processTailwindFeatures =
/*#__PURE__*/
_interop_require_default(require("./processTailwindFeatures"));

var _sharedState = require("./lib/sharedState");

var _findAtConfigPath = require("./lib/findAtConfigPath");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      var _findAtConfigPath1; // Use the path for the `@config` directive if it exists, otherwise use the
      // path for the file being processed


      configOrPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : configOrPath;
      var context = (0, _setupTrackingContext["default"])(configOrPath);

      if (root.type === "document") {
        var roots = root.nodes.filter(function (node) {
          return node.type === "root";
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = roots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _root2 = _step.value;

            if (_root2.type === "root") {
              (0, _processTailwindFeatures["default"])(context)(_root2, result);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return;
      }

      (0, _processTailwindFeatures["default"])(context)(root, result);
    }, false && function lightningCssPlugin(_root, result) {
      var postcss = require("postcss");

      var lightningcss = require("lightningcss");

      var browserslist = require("browserslist");

      try {
        var transformed = lightningcss.transform({
          filename: result.opts.from,
          code: Buffer.from(result.root.toString()),
          minify: false,
          sourceMap: !!result.map,
          inputSourceMap: result.map ? result.map.toString() : undefined,
          targets: typeof process !== "undefined" && process.env.JEST_WORKER_ID ? {
            chrome: 106 << 16
          } : lightningcss.browserslistToTargets(browserslist(require("../package.json").browserslist)),
          drafts: {
            nesting: true,
            customMedia: true
          }
        });

        var _result_map;

        result.map = Object.assign((_result_map = result.map) !== null && _result_map !== void 0 ? _result_map : {}, {
          toJSON: function toJSON() {
            return transformed.map.toJSON();
          },
          toString: function toString() {
            return transformed.map.toString();
          }
        });
        result.root = postcss.parse(transformed.code.toString("utf8"));
      } catch (err) {
        if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) {
          var lines = err.source.split("\n");
          err = new Error(["Error formatting using Lightning CSS:", ""].concat(["```css"].concat(_toConsumableArray(lines.slice(Math.max(err.loc.line - 3, 0), err.loc.line)), [" ".repeat(err.loc.column - 1) + "^-- " + err.toString()], _toConsumableArray(lines.slice(err.loc.line, err.loc.line + 2)), ["```"])).join("\n"));
        }

        if (Error.captureStackTrace) {
          Error.captureStackTrace(err, lightningCssPlugin);
        }

        throw err;
      }
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\n");
      return root;
    }].filter(Boolean)
  };
};

module.exports.postcss = true;